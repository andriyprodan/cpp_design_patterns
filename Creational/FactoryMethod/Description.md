### To switch between views, press Ctrl+Shift+V in the editor.

https://refactoring.guru/uk/design-patterns/factory-method

# Структура
1. Продукт визначає загальний інтерфейс об’єктів, які може створювати творець та його підкласи.
2. Конкретні продукти містять код різних продуктів. Продукти відрізнятимуться реалізацією, але інтерфейс у них буде спільним.
3. Творець оголошує фабричний метод, який має повертати нові об’єкти продуктів. Важливо, щоб тип результату цього методу співпадав із загальним інтерфейсом продуктів.  
Зазвичай, фабричний метод оголошують абстрактним, щоб змусити всі підкласи реалізувати його по-своєму. Однак він може також повертати продукт за замовчуванням.  
Незважаючи на назву, важливо розуміти, що створення продуктів не є єдиною і головною функцією творця. Зазвичай він містить ще й інший корисний код для роботи з продуктом. Аналогія: у великій софтверній компанії може бути центр підготовки програмістів, але все ж таки основним завданням компанії залишається написання коду, а не навчання програмістів.
4. Конкретні творці по-своєму реалізують фабричний метод, виробляючи ті чи інші конкретні продукти.  
Фабричний метод не зобов’язаний створювати нові об’єкти увесь час. Його можна переписати так, аби повертати з якогось сховища або кешу вже існуючі об’єкти.

![Structure](img/Structure.png "Structure")


# Приклад

Наприклад, класи `Вантажівка` і `Судно` реалізують інтерфейс `Транспорт` з методом `доставити`. Кожен з цих класів реалізує метод по-своєму: вантажівки перевозять вантажі сушею, а судна — морем. Фабричний метод класу `ДорожноїЛогістики` поверне об’єкт-вантажівку, а класу `МорськоїЛогістики` — об’єкт-судно.  
Клієнт фабричного методу не відчує різниці між цими об’єктами, адже він трактуватиме їх як якийсь абстрактний `Транспорт`. Для нього буде важливим, щоб об’єкт мав метод `доставити`, а не те, як конкретно він працює.

# Псевдокод
У цьому прикладі Фабричний метод допомагає створювати крос-платформові елементи інтерфейсу, не прив’язуючи основний код програми до конкретних класів кожного елементу.

![Pseudocode](img/Pseudocode.png "Pseudocode")

Фабричний метод оголошений у класі діалогів. Його підкласи належать до різних операційних систем. Завдяки фабричному методу, вам не потрібно переписувати логіку діалогів під кожну систему. Підкласи можуть успадкувати майже увесь код базового діалогу, змінюючи типи кнопок та інших елементів, з яких базовий код будує вікна графічного користувацього інтерфейсу.  
Базовий клас діалогів працює з кнопками через їхній загальний програмний інтерфейс. Незалежно від того, яку варіацію кнопок повернув фабричний метод, діалог залишиться робочим. Базовий клас не залежить від конкретних класів кнопок, залишаючи підкласам прийняття рішення про тип кнопок, які необхідно створити.


```c++
// Патерн Фабричний метод має сенс лише тоді, коли в програмі є
// ієрархія класів продуктів.
interface Button is
    method render()
    method onClick(f)

class WindowsButton implements Button is
    method render(a, b) is
        // Відобразити кнопку в стилі Windows.
    method onClick(f) is
        // Навісити на кнопку обробник подій Windows.

class HTMLButton implements Button is
    method render(a, b) is
        // Повернути HTML-код кнопки.
    method onClick(f) is
        // Навісити на кнопку обробник події браузера.


// Базовий клас фабрики. Зауважте, що "фабрика" — це всього лише
// додаткова роль для цього класу. Скоріше за все, він вже має
// якусь бізнес-логіку, яка потребує створення продуктів.
// Під "бізнес логікою" мається на увазі те, що діалог виконує і інші функції, окрім створення кнопок.
class Dialog is
    method render() is
        // Щоб використати фабричний метод, ви маєте
        // пересвідчитися, що ця бізнес-логіка не залежить від
        // конкретних класів продуктів. Button — це загальний
        // інтейрфейс кнопок, тому все гаразд.
        Button okButton = createButton()
        okButton.onClick(closeDialog)
        okButton.render()

    // Ми виносимо весь код створення продуктів до особливого
    // методу, який називають "фабричним".
    abstract method createButton():Button


// Конкретні фабрики перевизначають фабричний метод і повертають
// з нього власні продукти.
class WindowsDialog extends Dialog is
    method createButton():Button is
        return new WindowsButton()

class WebDialog extends Dialog is
    method createButton():Button is
        return new HTMLButton()


class Application is
    field dialog: Dialog

    // Програма створює певну фабрику в залежності від
    // конфігурації або оточення.
    method initialize() is
        config = readApplicationConfigFile()

        if (config.OS == "Windows") then
            dialog = new WindowsDialog()
        else if (config.OS == "Web") then
            dialog = new WebDialog()
        else
            throw new Exception("Error! Unknown operating system.")

    // Якщо весь інший клієнтський код працює з фабриками та
    // продуктами тільки через загальний інтерфейс, то для нього
    // байдуже, якого типу фабрику було створено на початку.
    method main() is
        this.initialize()
        dialog.render()
```

# Застосування
1. **Коли типи і залежності об’єктів, з якими повинен працювати ваш код, невідомі заздалегідь.**

Фабричний метод відокремлює код виробництва продуктів від решти коду, який використовує ці продукти.  
Завдяки цьому код виробництва можна розширювати, не зачіпаючи основний код. Щоб додати підтримку нового продукту, вам потрібно створити новий підклас та визначити в ньому фабричний метод, повертаючи звідти екземпляр нового продукту.

2. **Коли ви хочете зекономити системні ресурси, повторно використовуючи вже створені об’єкти, замість породження нових.**

Така проблема зазвичай виникає під час роботи з «важкими», вимогливими до ресурсів об’єктами, такими, як підключення до бази даних, файлової системи й подібними.  
Уявіть, скільки дій вам потрібно зробити, аби повторно використовувати вже існуючі об’єкти:  
1) Спочатку слід створити загальне сховище, щоб зберігати в ньому всі створювані об’єкти.
2) При запиті нового об’єкта потрібно буде подивитись у сховище та перевірити, чи є там невикористаний об’єкт.
3) Потім повернути його клієнтському коду.  
4) Але якщо ж вільних об’єктів немає, створити новий, не забувши додати його до сховища.

Увесь цей код потрібно десь розмістити, щоб не засмічувати клієнтський код.  
Найзручнішим місцем був би конструктор об’єкта, адже всі ці перевірки потрібні тільки під час створення об’єктів, але, на жаль, конструктор завжди створює нові об’єкти, тому він не може повернути існуючий екземпляр.  
Отже, має бути інший метод, який би віддавав як існуючі, так і нові об’єкти. Ним і стане фабричний метод.  

# Переваги та недоліки

### Переваги
1. Позбавляє клас від прив’язки до конкретних класів продуктів.
2. Виділяє код виробництва продуктів в одне місце, спрощуючи підтримку коду.
3. Спрощує додавання нових продуктів до програми.
4. Реалізує принцип відкритості/закритості.

### Недоліки
Може призвести до створення великих паралельних ієрархій класів, адже для кожного класу продукту потрібно створити власний підклас творця.